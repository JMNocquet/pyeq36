#!/usr/local/geodesy/anaconda38/bin/python

###################################################################
# SCRIPT    : pyeq_static_inversion.py
# AUTHOR    : 
# DATE      : March 2013 - reorganized February 2016
# NOTE      : InSAR added July 2018 - python 3.6 version September 2018
###################################################################

###################################################################
# MODULES IMPORT
###################################################################
import sys
import argparse
from argparse import RawTextHelpFormatter
import numpy as np
import pyacs.lib.euler
import pyacs.lib.faultslip

import pyeq.optimization.wrapper.make_inversion
from pyeq.lib import lib_inversion

from time import time
t0 = time()

###################################################################
# PARSE ARGUMENT LINE
###################################################################

prog_info="pyeq_model_make_inversion.py : performs inversion of slip values\n"
prog_info+="--------------------------------------------------------------------------------------------------------------------------------------\n"
prog_info+="REQUIRED INPUT FOR ALL INVERSION SCHEMES\n"
prog_info+="--------------------------------------------------------------------------------------------------------------------------------------\n"
prog_info+="    - input npy file generated by pyeq_model_make_green\n"
prog_info+="    - Inversion scheme\n"
prog_info+="    - Parameters controlling the weight of regularization\n"
prog_info+="    - Experiment name\n"
prog_info+="OPTIONAL INPUT\n"
prog_info+="--------------------------------------------------------------------------------------------------------------------------------------\n"
prog_info+="    - verbose/debug mode\n"
prog_info+="--------------------------------------------------------------------------------------------------------------------------------------\n"
prog_info+="LINEAR BAYESIAN SCHEME (bayesian)\n"
prog_info+="--------------------------------------------------------------------------------------------------------------------------------------\n"
prog_info+="Required parameters are:\n"
prog_info+="    - sigma      : regularization value. 1/sigma**2 is the weight given to regularization (Cm-1) (mm or mm/yr)\n"
prog_info+="    - max_slip   : 0 no constraint, Euler calculated from Euler pole, or any float value\n"
prog_info+="    - m0         : a priori model; any real number [0-1]; 0=null a priori model; 1= a priori max_slip\n"

prog_epilog="J.-M. Nocquet (Geoazur-CNRS) - November 2012 (bayesian), March 2013 (bounded inversion), October 2014"

#----------------------------------------------------------
# PARSE COMMAND LINE
#----------------------------------------------------------

parser = argparse.ArgumentParser(description=prog_info,epilog=prog_epilog,formatter_class=RawTextHelpFormatter)

# input
parser.add_argument('-input_npz', action='store', dest='input_npz',type=str,default=None,help='input npz file generated by pyeq_make_green.py')

# regularization parameters
parser.add_argument('-dc', action='store', dest='dc',type=float,default=None,help='Correlation length in km')
parser.add_argument('-sigma', action='store' ,dest='sigma', default=None, type=float, help='sigma in mm or mm/yr ; weight of the regularization')
parser.add_argument('-m0', action='store' ,dest='m0',  default=None, type=float, help='a priori value for the slip model. Only holds for the main rake because prior for conjugate is always 0.'+\
                    ' if max_slip option is 0, that is max_slip is calculated from an Euler pole, then the m0 option is understood as a factor applied to max_slip. In that case, '+\
                    'm0=0. means null coupling prior, m0=1. full coupling prior, m=0.5 half coupling prior.')

# inversion type parameters
parser.add_argument('-rake_type', action='store' ,dest='rake_type', default='Euler', type=str, help='rake_type: Euler or constant')
parser.add_argument('-rake_value', action='store' ,dest='rake_or_pole', required=True, type=str, help='Euler pole /long/lat/w/style (style among inverse, normal, leftlateral,rightlateral) or rake value in degrees')
parser.add_argument('-rake_constraint', action='store' ,dest='rake_constraint', required=True, type=float, help='constraint on rake; 0 means fixed, any positive value means sigma on the complement of the principal rake')
parser.add_argument('-max_slip', action='store' ,dest='max_slip', type=float, default=-1,help='constraints on the maximum slip. 0 means maximum from Euler pole, any negative number means no bounds')

# observation weight
parser.add_argument('-wh', action='store', dest='wh',type=float,default=1.0,help='uncertainty rescaling factor for horizontal GPS')
parser.add_argument('-wu', action='store', dest='wu',type=float,default=1.0,help='uncertainty rescaling factor for vertical   GPS')
parser.add_argument('-wi', action='store', dest='wi',type=float,default=1.0,help='uncertainty rescaling factor for InSAR')

# InSAR correction constraints
parser.add_argument('-ci', action='store', dest='ci',type=str,default='1./1./10.',help='constraints on InSAR corrections')

# manual constraint for resolution test
parser.add_argument('--c', action='append' ,dest='c',  default=None, type=str, help='constraints on a specific patch n/min_value/max_value')

# insar
parser.add_argument('--insar', action='count',default=0,help='also includes InSAR data in the inversion')

# shp_line
parser.add_argument('--shp_line', action='append', type=str, dest='shp_line',default=[],help='line shapefile. Can be repeated')
parser.add_argument('--shp_poly', action='append', type=str, dest='shp_poly',default=[],help='poly shapefile. Can be repeated')

# name
parser.add_argument('--name', action='store', type=str, dest='name',default=None,help='outdir name')

# verbose/debug/save modes
parser.add_argument('--verbose', '-v', action='count',default=0,help='verbose mode')
parser.add_argument('--debug', action='count',default=0,help='debug mode')
parser.add_argument('--save', action='count',default=0,help='save G,d,Cd, lower, upper matrices/vectors and stop')

# output name
parser.add_argument('-e', action='store',type=str,default='', dest='experiment',help='experiment name')


args = parser.parse_args()

if (len(sys.argv)<2):parser.print_help();sys.exit()

#############################################################################################################
# INITIALIZATION
#############################################################################################################
import os
abs_path_input_npz=os.path.abspath(args.input_npz)

H_inversion_info={'input_npz':abs_path_input_npz,        \
                  'sigma':args.sigma,                    \
                  'm0':args.m0,                          \
                  'dc':args.dc,                          \
                  'rake_type':args.rake_type,            \
                  'rake_value':args.rake_or_pole,        \
                  'rake_constraint':args.rake_constraint,\
                  'max_slip':args.max_slip,              \
                  'cmd_line':" ".join(sys.argv),         \
                  'wh': args.wh,                         \
                  'wu': args.wu,                         \
                  'wi': args.wi}



# verbose
if args.verbose>0:
    print("-- Verbose mode")
    verbose=True
else:
    verbose=False
# debug
if args.debug>0:
    print("-- Debug mode")
    verbose=True
    debug=True
else:
    debug=False

# save option
if args.save>0:
    print("-- Save mode")
    save_mode=True
else:
    save_mode=False

# constraints on InSAR corrections
[ca,cb,cc] = list(map(float,args.ci.split('/')))

# insar option
if args.insar>0:
    print("-- InSAR data included in the inversion")
    insar_mode=True
    H_inversion_info['insar'] = True
    H_inversion_info['big'] = big = 10000.
else:
    insar_mode=False
    H_inversion_info['insar'] = False
    H_inversion_info['big'] = big = 0.0
    [ca,cb,cc] = [0.,0.,0.]
    args.wi = 0.

# variable_rake
if args.rake_constraint >0:
    H_inversion_info['big_rake_constraint'] = 1000.
else:
    H_inversion_info['big_rake_constraint'] = 0.

H_inversion_info['ci'] = args.ci

if args.experiment != '':
    name=("%s_s_%03d_dc_%03d_m0_%03d_h_%02d_u_%02d_i_%02d_%02d_%02d_%02d" % \
          (args.experiment,int(args.sigma),int(args.dc),int(args.m0*100.0),args.wh,args.wu,args.wi,ca,cb,cc ) )
else:
    name=("sigma_%03d_dc_%03d_m0_%03d" % (int(args.sigma),int(args.dc),int(args.m0*100.0)))

if args.name is not None:
    name = args.name

###################################################################
# PYTHON 2.7 READING INPUT NPY FILES
###################################################################
# if not insar_mode:
#     try:
#         f = file(args.input_npy,"rb")
#         GEOMETRY=np.load(f)
#         Dm=np.load(f)
#         GREEN=np.load(f)
#         GREEN_UP=np.load(f)
#         OBS=np.load(f)
#         NAME_OBS=np.load(f)
#         OBS_UP=np.load(f)
#         NAME_OBS_UP=np.load(f)
#         f.close()
#     except:
#         print("!!! Could not read ",args.input_npy)
#         sys.exit()
# else:
#     try:
#         f = file(args.input_npy,"rb")
#         GEOMETRY    = np.load(f)
#         Dm          = np.load(f)
#         GREEN       = np.load(f)
#         GREEN_UP    = np.load(f)
#         OBS         = np.load(f)
#         NAME_OBS    = np.load(f)
#         OBS_UP      = np.load(f)
#         NAME_OBS_UP = np.load(f)
#         GREEN_INSAR = np.load(f)
#         OBS_INSAR   = np.load(f)
#         f.close()
#     except:
#         print("!!! Could not read ",args.input_npy)
#         sys.exit()
#     
# 
# SGEOMETRY=np.rec.array(GEOMETRY)

###################################################################
# PYTHON 3.6 READING INPUT NPZ FILE
###################################################################

# PYHTON 3.6

INPUT = np.load(args.input_npz)

GEOMETRY    = INPUT["GEOMETRY"]
Dm          = INPUT["Dm"]
GREEN       = INPUT["GREEN"]
GREEN_UP    = INPUT["GREEN_UP"]
OBS         = INPUT["OBS"]
NAME_OBS    = INPUT["NAME_OBS"]
OBS_UP      = INPUT["OBS_UP"]
NAME_OBS_UP = INPUT["NAME_OBS_UP"]
GREEN_INSAR = INPUT["GREEN_INSAR"]
OBS_INSAR   = INPUT["OBS_INSAR"]

# converts array to recarray

names=['rdis_long','rdis_lat','rdis_depth','rdis_length','rdis_width',\
       'rdis_area','ratio_rdis_tdis','strike','dip',\
       'centroid_long','centroid_lat','centroid_depth',\
       'tdis_long1','tdis_lat1','tdis_depth1',\
       'tdis_long2','tdis_lat2','tdis_depth2',\
       'tdis_long3','tdis_lat3','tdis_depth3','tdis_area']

SGEOMETRY=lib_inversion.numpy_array_2_numpy_recarray(GEOMETRY,names)



###################################################################
# PREPARE MATRICES FOR INVERSION
###################################################################

print('-- Preparing matrices for inversions')

###################################################################
# OBSERVATION
###################################################################


print('-- Making observation vector d ')
# the organization is as followed d = [d_east,d_north,d_up].T
if isinstance(OBS_UP,np.ndarray) and OBS_UP.shape[0]>0:
    DATA_VECTOR=np.hstack((OBS[:,2:4].T.ravel(),OBS_UP[:,2].T.ravel()))
else:
    DATA_VECTOR=OBS[:,2:4].T.ravel()


ngps=OBS.shape[0]
ngps_up=OBS_UP.shape[0]

if insar_mode:
    DATA_VECTOR = np.hstack( (DATA_VECTOR,OBS_INSAR[:,2]) )
    n_insar = OBS_INSAR[:,2].shape[0]
else:
    n_insar = 0
    
print("-- Observation vector has length: ", DATA_VECTOR.shape[0])
print("-- n_gps " ,ngps)
print("-- n_up " , ngps_up)
print("-- n_insar ", n_insar)
if save_mode:
    print('-- Saving observation vector as d.npy')
    np.save('d.npy',DATA_VECTOR)


###################################################################
# MODEL MATRIX
###################################################################

print('-- Making model matrix G')

# first re-order the Green's functions
# GREEN IS A TENSOR OF DIM 4
# GREEN(i,j,k,l) is the prediction for dislocation i at site j component k for rake l
# k=0,1,2 = east, north, up
# l=0,1 : rake_00 & rake_90

GREEN_4GPS_EAST_RAKE_00=GREEN[:,:,0,0].T
GREEN_4GPS_EAST_RAKE_90=GREEN[:,:,0,1].T


GREEN_4GPS_NORTH_RAKE_00=GREEN[:,:,1,0].T
GREEN_4GPS_NORTH_RAKE_90=GREEN[:,:,1,1].T

if GREEN_UP.shape[0] > 0:
    GREEN_4UP_RAKE_00=GREEN_UP[:,:,2,0].T
    GREEN_4UP_RAKE_90=GREEN_UP[:,:,2,1].T

if insar_mode:
    # get the unit LOS direction vector for each InSAR observation point
    U = OBS_INSAR[:,-3:]
    if GREEN_INSAR.shape[0] > 0:
        GREEN_4INSAR_RAKE_00 =   GREEN_INSAR[:,:,0,0].T * U[:,0].reshape(-1,1)    \
                               + GREEN_INSAR[:,:,1,0].T * U[:,1].reshape(-1,1)    \
                               + GREEN_INSAR[:,:,2,0].T * U[:,2].reshape(-1,1) 

        GREEN_4INSAR_RAKE_90 =   GREEN_INSAR[:,:,0,1].T * U[:,0].reshape(-1,1)    \
                               + GREEN_INSAR[:,:,1,1].T * U[:,1].reshape(-1,1)    \
                               + GREEN_INSAR[:,:,2,1].T * U[:,2].reshape(-1,1) 

#         print GREEN_INSAR[0,0,0,0].T,GREEN_INSAR[0,0,1,0].T,GREEN_INSAR[0,0,2,0].T
#         print U[0,0],U[0,1],U[0,2]
#         
#         print GREEN_INSAR[0,0,0,0].T*U[0,0]+GREEN_INSAR[0,0,1,0].T*U[0,1]+GREEN_INSAR[0,0,2,0].T*U[0,2]
#         print GREEN_4INSAR_RAKE_00[0,0]
# 
# sys.exit()

# dealing with the principal rake

RAKE=np.zeros(GEOMETRY.shape[0])
VEL_FROM_EULER=np.zeros(GEOMETRY.shape[0])

if args.rake_type=='Euler' or args.rake_type=='euler':
    
    tmp,elon,elat,ew,motion_type=args.rake_or_pole.split('/')
    pole=("%s/%s/%s" % (elon,elat,ew))

    for i in range(GEOMETRY.shape[0]):
        [x,y,strike,dip]=[SGEOMETRY.rdis_long[i],SGEOMETRY.rdis_lat[i],SGEOMETRY.strike[i],SGEOMETRY.dip[i]]
        (ve,vn) = pyacs.lib.euler.vel_from_euler( x , y , float(elon) , float(elat) , float(ew) )
        RAKE[i] = pyacs.lib.faultslip.v_to_rake(ve,vn,strike,dip,motion_type)
        VEL_FROM_EULER[i]=np.sqrt(ve**2+vn**2)

else:
    RAKE=RAKE+float(args.rake_or_pole)

   
RAKE_RADIANS=np.radians(RAKE)
CONJUGATE_RAKE_RADIANS=np.radians(RAKE+90.0)

# Now calculating the Green's functions in the principal and conjugate rake directions

# GPS HORIZONTAL

GREEN_4GPS_EAST_RAKE_PRINCIPAL =np.cos(RAKE_RADIANS)*GREEN_4GPS_EAST_RAKE_00+np.sin(RAKE_RADIANS)*GREEN_4GPS_EAST_RAKE_90
GREEN_4GPS_NORTH_RAKE_PRINCIPAL=np.cos(RAKE_RADIANS)*GREEN_4GPS_NORTH_RAKE_00+np.sin(RAKE_RADIANS)*GREEN_4GPS_NORTH_RAKE_90

GREEN_4GPS_EAST_RAKE_CONJUGATE=np.cos(CONJUGATE_RAKE_RADIANS)*GREEN_4GPS_EAST_RAKE_00+np.sin(CONJUGATE_RAKE_RADIANS)*GREEN_4GPS_EAST_RAKE_90
GREEN_4GPS_NORTH_RAKE_CONJUGATE=np.cos(CONJUGATE_RAKE_RADIANS)*GREEN_4GPS_NORTH_RAKE_00+np.sin(CONJUGATE_RAKE_RADIANS)*GREEN_4GPS_NORTH_RAKE_90

# UP

if GREEN_UP.shape[0] > 0:
    GREEN_4GPS_UP_RAKE_PRINCIPAL=np.cos(RAKE_RADIANS)*GREEN_4UP_RAKE_00+np.sin(RAKE_RADIANS)*GREEN_4UP_RAKE_90
    GREEN_4GPS_UP_RAKE_CONJUGATE=np.cos(CONJUGATE_RAKE_RADIANS)*GREEN_4UP_RAKE_00+np.sin(CONJUGATE_RAKE_RADIANS)*GREEN_4UP_RAKE_90

# INSAR
if insar_mode:
    if GREEN_INSAR.shape[0] > 0:
        GREEN_4INSAR_RAKE_PRINCIPAL = np.cos(RAKE_RADIANS)*GREEN_4INSAR_RAKE_00+np.sin(RAKE_RADIANS)*GREEN_4INSAR_RAKE_90 
        GREEN_4INSAR_RAKE_CONJUGATE = np.cos(CONJUGATE_RAKE_RADIANS)*GREEN_4INSAR_RAKE_00+np.sin(CONJUGATE_RAKE_RADIANS)*GREEN_4INSAR_RAKE_90 
    
    print('-- GREEN_4INSAR_RAKE_PRINCIPAL.shape ', GREEN_4INSAR_RAKE_PRINCIPAL.shape)

# setting G

# case fixed rake
if args.rake_constraint==0.0:
    if GREEN_UP.shape[0] > 0:
        MODEL_MATRIX=np.vstack((np.vstack((GREEN_4GPS_EAST_RAKE_PRINCIPAL,GREEN_4GPS_NORTH_RAKE_PRINCIPAL)),GREEN_4GPS_UP_RAKE_PRINCIPAL))
    else:
        MODEL_MATRIX=np.vstack((GREEN_4GPS_EAST_RAKE_PRINCIPAL,GREEN_4GPS_NORTH_RAKE_PRINCIPAL))

    if insar_mode:
        MODEL_MATRIX = np.vstack(( MODEL_MATRIX , GREEN_4INSAR_RAKE_PRINCIPAL ))

# case variable rake

else:
    # first stack the Green's function horizontally
    GREEN_4GPS_EAST_ALL_RAKE=np.hstack((GREEN_4GPS_EAST_RAKE_PRINCIPAL,GREEN_4GPS_EAST_RAKE_CONJUGATE))
    GREEN_4GPS_NORTH_ALL_RAKE=np.hstack((GREEN_4GPS_NORTH_RAKE_PRINCIPAL,GREEN_4GPS_NORTH_RAKE_CONJUGATE))
    if GREEN_UP.shape[0] > 0:
        GREEN_4GPS_UP_ALL_RAKE=np.hstack((GREEN_4GPS_UP_RAKE_PRINCIPAL,GREEN_4GPS_UP_RAKE_CONJUGATE))
        MODEL_MATRIX=np.vstack((np.vstack((GREEN_4GPS_EAST_ALL_RAKE,GREEN_4GPS_NORTH_ALL_RAKE)),GREEN_4GPS_UP_ALL_RAKE))
    else:
        MODEL_MATRIX=np.vstack((GREEN_4GPS_EAST_ALL_RAKE,GREEN_4GPS_NORTH_ALL_RAKE))

    if insar_mode:
        GREEN_4INSAR_ALL_RAKE=np.hstack((GREEN_4INSAR_RAKE_PRINCIPAL,GREEN_4INSAR_RAKE_CONJUGATE))
        MODEL_MATRIX = np.vstack(( MODEL_MATRIX , GREEN_4INSAR_ALL_RAKE ))
    
# INSAR CASE, WE NEED TO ESTIMATE A PLANE SIMULTANEOUSLY TO THE MODEL PARAMETERS

if insar_mode:
    print('-- Adding a plane correction as model parameter for InSAR data')

    # reference point for the plane equation
    lon_ref = np.median(OBS_INSAR[:,0]) 
    lat_ref = np.median(OBS_INSAR[:,1]) 
    
    # add 3 x null columns to MODEL_MATRIX
    MODEL_MATRIX = np.append(MODEL_MATRIX,np.zeros((MODEL_MATRIX.shape[0],3)),axis=1)

    # add the plane correction to INSAR rows of MODEL_MATRIX
    
    MODEL_MATRIX[2*ngps+ngps_up:,-3] = OBS_INSAR[:,0] - lon_ref
    MODEL_MATRIX[2*ngps+ngps_up:,-2] = OBS_INSAR[:,1] - lat_ref
    MODEL_MATRIX[2*ngps+ngps_up:,-1] = 1
    
    # add the change of variable correction to the observation
    
    DATA_VECTOR[2*ngps+ngps_up:] = DATA_VECTOR[2*ngps+ngps_up:] \
                                   + (OBS_INSAR[:,0] - lon_ref)*big \
                                   + (OBS_INSAR[:,1] - lat_ref)*big \
                                   + (OBS_INSAR[:,0]*0.0 + big)


print("-- size of the MODEL_MATRIX G ",MODEL_MATRIX.shape)

if save_mode:
    print('-- Saving model matrix as G.npy')
    np.save('G.npy',MODEL_MATRIX)
    
if debug:
    print('G')
    print(MODEL_MATRIX)

###################################################################
# SLIP BOUNDS
###################################################################

print('-- Dealing with the bounds on slip (max_slip)')

slip_no_constraint=100000.0 # 100 m

# SLIP_BOUNDS is a two column matrix having lower_bound and upper_bound in column 0 & 1

SLIP_BOUNDS=np.zeros((MODEL_MATRIX.shape[1],2))
SLIP_BOUNDS[:,0]=SLIP_BOUNDS[:,0]*0.0-slip_no_constraint
SLIP_BOUNDS[:,1]=SLIP_BOUNDS[:,1]*0.0+slip_no_constraint

MAX_SLIP=np.zeros((GEOMETRY.shape[0]))*0.0+slip_no_constraint

if args.max_slip<0:
    # No upper_bound constraint
    # only non negative constraints on the rake principal slip
    SLIP_BOUNDS[0:GEOMETRY.shape[0],0]=0.0
    print("-- Not a bounded inversion. No slip bounds filled")
elif args.max_slip==0.0:
    # Upper bound from Euler pole, applies only on the principal rake
    SLIP_BOUNDS[0:GEOMETRY.shape[0],1]=VEL_FROM_EULER
    # NN constraints
    SLIP_BOUNDS[0:GEOMETRY.shape[0],0]=0.0
    MAX_SLIP=VEL_FROM_EULER
    print("-- Slip bounds filled from Euler pole " , np.min(SLIP_BOUNDS[:,0]),' -- ', np.max(SLIP_BOUNDS[:,1]))
elif args.max_slip>0.0:
    # Upper bound provided
    SLIP_BOUNDS[0:GEOMETRY.shape[0],1]=args.max_slip
    # NN constraints
    SLIP_BOUNDS[0:GEOMETRY.shape[0],0]=0.0
    MAX_SLIP=MAX_SLIP*0.0+args.max_slip
    print("-- Slip bounds filled")

if args.rake_constraint >0:
    SLIP_BOUNDS[GEOMETRY.shape[0]:,0] = -1.E6
    SLIP_BOUNDS[GEOMETRY.shape[0]:,1] =  1.E6

if debug:
    print('SLIP BOUNDS')
    print(SLIP_BOUNDS)
    print('MAX SLIP')
    print(MAX_SLIP)


if save_mode:
    print('-- Saving lower and upper bounds vector as lower.npy and upper.npy')
    np.save('upper.npy',MAX_SLIP)
    np.save('lower.npy',MAX_SLIP*0.0)


###################################################################
# A PRIORI MODEL M0
###################################################################

print("-- Dealing with a priori model")

m0=np.zeros((MODEL_MATRIX.shape[1]))

# non zero a priori model only applies to the principal rake
if args.m0 > 0.0:
    # case args.max_slip from Euler
    if args.max_slip == 0:
        m0[0:GEOMETRY.shape[0]+1] = MAX_SLIP
    else:
        m0[0:GEOMETRY.shape[0]+1]= args.m0

if insar_mode:
    m0[-3:] = big


###################################################################
# CHANGES BOUNDS IF --C OPTION USED
###################################################################

if isinstance(args.c,list):
    print("-- Modifying bounds according the -c option")
    for str_constraint in args.c:
        str_dis,str_constraint_lower,str_constraint_upper=str_constraint.split('/')
        min_constraint=float(str_constraint_lower)
        max_constraint=float(str_constraint_upper)
        n_dis=int(str_dis)
        print("-- Constraining dislocation #",n_dis, " within bounds ",min_constraint,max_constraint)
        SLIP_BOUNDS[n_dis,1]=max_constraint
        SLIP_BOUNDS[n_dis,0]=min_constraint

###################################################################
# Cd -still needs check for up and InSAR
###################################################################

print('-- Building data covariance and weight matrix')
print('-- Correlation neglected')

Cd=np.zeros((2*ngps+ngps_up+n_insar,2*ngps+ngps_up+n_insar))

# if std deviation are zero, set it to 1.
if np.count_nonzero( OBS[:,4:6] ) == 0:
    print("-- warning: data have no uncertainty. Setting to 1.")
    OBS[:, 4:6] = 1.

Cd_gps_east  = args.wh**2 * OBS[:,4]**2
Cd_gps_north = args.wh**2 * OBS[:,5]**2
if GREEN_UP.shape[0] > 0:
    Cd_gps_up    = args.wu**2 * OBS_UP[:,3]**2

if insar_mode:
    print(('-- InSAR Uncertainties min/max/median %.1lf/%.1lf/%.1lf' % (np.min(OBS_INSAR[:,3]) , np.max(OBS_INSAR[:,3]) , np.median(OBS_INSAR[:,3])))) 
    Cd_insar     = args.wi**2 *  OBS_INSAR[:,3]**2
    if GREEN_UP.shape[0] > 0:
        Cd = np.diag( np.hstack( (Cd_gps_east,Cd_gps_north,Cd_gps_up,Cd_insar) ) )
    else:
        Cd = np.diag( np.hstack( (Cd_gps_east,Cd_gps_north,Cd_insar) ) )
        
else:
    if GREEN_UP.shape[0] > 0:
        Cd = np.diag( np.hstack( (Cd_gps_east,Cd_gps_north,Cd_gps_up) ) )
    else:
        Cd = np.diag( np.hstack( (Cd_gps_east,Cd_gps_north) ) )
        
print('-- Cd shape ', Cd.shape)

# for i in range(ngps):
#     Cd[i,i]=OBS[i,4]**2
#     Cd[ngps+i,ngps+i]=OBS[i,5]**2
    
    # we assume correlation coefficient in the gps file and convert it to covariances
    #Cd[i,ngps+i]=OBS[i,6]*OBS[i,4]*OBS[i,5]
    # corr(Ve,Vn) are neglected

# for i in range(ngps_up):
#     Cd[2*ngps+i,2*ngps+i]=OBS_UP[i,3]**2

if save_mode:
    print('-- Saving observation covariance matrix as Cd.npy')
    np.save('Cd.npy',Cd)


###################################################################
# LINEAR SYSTEM NORMALIZATION
###################################################################

G=MODEL_MATRIX
d=DATA_VECTOR

Cm=lib_inversion.make_isotropic_exponential_Cm(Dm,args.dc,args.sigma)

LL=np.linalg.cholesky(Cm)
SQRT_Wm=np.linalg.inv(LL)

# This is saved for chi2 calculation in print_log_static
H_inversion_info['SQRT_Wm'] = SQRT_Wm=np.linalg.inv(LL)


if insar_mode:
    # we need to add 3 terms for the plane parameter estimates
    
    Cm = np.append(Cm,np.zeros((Cm.shape[0],3)),axis=1)
    Cm = np.append(Cm,np.zeros((3,Cm.shape[1])),axis=0)
    
    Cm[-3,-3] = ca**2
    Cm[-2,-2] = cb**2
    Cm[-1,-1] = cc**2

if save_mode:
    print('-- Saving model covariance matrix as Cm.npy')
    np.save('Cm.npy',Cm)
    mm,Cmm,Hmm = lib_inversion.sol_unbounded_gaussian(\
                    m0,G,Cm,Cd,d,verbose=True,return_precision_matrix=True)

    print('-- Saving unconstrained solution (Tarantola-Valette) as mm.npy')
    np.save('mm.npy',mm.flatten())

    print('-- Saving unconstrained posterior covariance (Tarantola-Valette) as Cmm.npy')
    np.save('Cmm.npy',Cmm)

    sys.exit()

A,B,SQRT_Wm,SQRT_Wd=lib_inversion.normalize_linear_system(\
                    G,d,m0,Cd,Cm,args.rake_constraint,\
                    insar=insar_mode,verbose=verbose)

ATA = np.dot(A.T,A)
ATB = np.dot(A.T,B.reshape(-1,1))

###################################################################
# MAKING THE INVERSION
###################################################################
    # calculate SOLUTION
    
    #SLIP=pyeq_model2_inversion.make_inversion_linear_bayesian(G,d,Cd,Cm,1.0,m0,verbose=True)
    
    # Calculates Sm at SLIP
    
    #print 'Sm min from m tilde',pyeq_model2_inversion.Sm(G,SLIP,d,Cd,m0,Cm)
    
    # Calculate (Gm0-d)t (GCmGt + Cd)^-1 (Gm0-d)

    #print 'Sm min from Tarantola p178 .92 ',pyeq_model2_inversion.Sm_min(G,d,Cd,m0,Cm)

    #sys.exit()

print("-- Now doing the inversion")


if (not isinstance(args.c,list)) and args.max_slip<0. and args.rake_constraint == 0.:
    # NNLS CASE
#    SLIP,norm=pyeq_model2_inversion.make_inversion_nnls(A,B,SLIP_BOUNDS,verbose=True)
    print("-- Doing inversion using the nnlsm_block_pivot algorithm")
    SLIP,norm = pyeq.optimization.wrapper.make_inversion.pyeq_nnls(ATA, ATB, 'nnlsm_block_pivot', verbose=verbose)
else:
    # BVLS CASE
    print("-- Doing inversion using the BVLS algorithm")
    SLIP,norm = pyeq.optimization.wrapper.make_inversion.pyeq_bvls(A, B, SLIP_BOUNDS, verbose=True)


###################################################################
# MAKING THE UNBOUNDED INVERSION
###################################################################

# NO_BOUNDS=np.copy(SLIP_BOUNDS)
# NO_BOUNDS[:,0]=NO_BOUNDS[:,0]*0.0-100000.0
# NO_BOUNDS[:,1]=NO_BOUNDS[:,0]*0.0+100000.0
# 
# print "=> Calculating the unbounded solution"
# SLIP_NO_BOUNDS,norm_no_bounds=pyeq_model2_inversion.make_inversion_bvls(A,B,NO_BOUNDS,verbose=True)
# 
# print "=> Getting renormalization factors for the a posteriori pdf for the bounded solution"
# renormalization_factor=pyeq_model2_inversion.renormalization_bounded_inversion(A,SLIP_NO_BOUNDS,SLIP_BOUNDS)

renormalization_factor=1

###################################################################
#PRINTING INVERSION RESULTS
###################################################################

###################################################################
# GENERAL NAME
###################################################################

print("-- Printing results in ",name)
#if not path.exists(name):mkdir(name)


#(RESIDUALS,RESIDUALS_UP,MODEL,MODEL_UP,SOURCES_SLIP)=\
#pyeq_model2_inversion.make_results(MODEL_MATRIX,SLIP, SOURCES,OBS, OBS_UP,d)

H_inversion_info['time']=time()-t0
H_inversion_info['norm_bvls']=norm
H_inversion_info['renormalization_factor']=renormalization_factor

import pyeq.lib.print_log_static

pyeq.lib.print_log_static.print_static_inversion_results(SLIP, G, d, args.input_npz , RAKE, MAX_SLIP, name, SQRT_Wm, SQRT_Wd, m0, H_inversion_info)

###################################################################
# MAKE PLOTS
###################################################################

def get_max_scale(mx):
    import numpy as np
    scale = np.arange(10 ** int(np.log10(mx)), 10 ** (int(np.log10(mx)) + 1) + 10 ** int(np.log10(mx)),
                      10 ** int(np.log10(mx)))
    return scale[np.where(scale > mx)][0]


# make shapefile

import pyacs.lib.shapefile
import glob
from os import mkdir, path

outdir = name + '/plots'
if not path.exists(outdir): mkdir(outdir)

sol_slip_dat = glob.glob( name+'/*_sol_slip.dat')[0]
shp = ("%s/sol_slip.shp" % name)
dis_type = 'tde'

pyacs.lib.shapefile.static_slip_to_shapefile(sol_slip_dat, shp, dis_type, verbose)

from pyeq.plot import plot_model_shp
from pyeq.lib.objects import pyeq_model

model = pyeq_model()
model.odir = name

bounds = np.linspace(0, get_max_scale(np.max(SLIP)), 21)
model.external_shapefile_poly = args.shp_poly
model.external_shapefile_line = args.shp_line

outdir = model.odir + '/plots/model_cumulative'
if not path.exists(outdir): mkdir(outdir)

model_disp_name = glob.glob( name+'/*_model.dat')[0]
obs_disp_name = glob.glob( name+'/*_obs.dat')[0]

# cumulative slip plot
plot_model_shp\
     (shp, \
      cmap='magma_r', \
      ncolor=20, \
      contour=None, \
      crs=None, \
      log=False, \
      title=name, \
      bounds=bounds, \
      outdir=outdir, \
      outfile=None, \
      shp_poly=model.external_shapefile_poly, \
      shp_line=model.external_shapefile_line, \
      shp_point=None, \
      disp = [obs_disp_name,model_disp_name])

outdir = model.odir + '/plots/model_cumulative_contour'
if not path.exists(outdir): mkdir(outdir)
print('-- making contour plot for cumulative slip in ', outdir)

# cumulative slip contour plot
plot_model_shp\
         (shp, \
          cmap='magma_r', \
          ncolor=20, \
          contour=2, \
          crs=None, \
          log=False, \
          title=name, \
          bounds=[0., np.max(SLIP)], \
          outdir=outdir, \
          outfile=None, \
          shp_poly=model.external_shapefile_poly, \
          shp_line=model.external_shapefile_line, \
          shp_point=None)

